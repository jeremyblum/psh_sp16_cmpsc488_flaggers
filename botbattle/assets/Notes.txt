Initial game state: Pass a map and a series of create commands
Playback mode: GSD is passed all commands for the game and instantly computes all game states
Testing Mode: GSD instantly computes next game state when given commands and then animates
Basically, if a turn is available, then the GSD knows its game state info

All commands on a turn execute simultaneously, except for multiple commands for the same entity, which execute sequentially

Storing Data
-For every map:
--Store a 2d array of background tiles for the initial game state.
---Each element in the array should be an object consisting of a spritesheet (string) and index (integer)
----Ex. {sheet: 'tiles', index: 2};
--Store initial commands (most or all of these will be 'create' commands to instantiate things like players, walls, flags)
--Ex.
	{id: 'player', cmd: 'create', type: 'player', sprite: 'dude', x: 1, y: 5},
	{id: 'star', cmd: 'create', type: 'star', sprite: 'star', x: 2, y: 7},
	{id: 'diamond', cmd: 'create', type: 'diamond', sprite: 'diamond', x: 2, y: 13}

-For every match
--Whatever you or the other group need

-For every turn in a match
--Commands (see above)
--Will work differently for each game challenge
---For instance, in CTF you might want to move the player "up", "up", "left" in one turn, whereas in something like chess you'd want to move the rook "up 5" in a single command
---Further examples:
	{id: 'player', cmd: 'pickupflag'}
	{id: 'player', cmd: 'move', x: 3, y: 12}
	{id: 'player', cmd: 'move', dir: 'up'}

-For testing mode matches only:
--Store every state in such a way that you can reload a previous state and send it to the game evaluation module on command
---You'll get a command like {cmd: 'undo', turns: 3} to undo 3 turns, followed by the commands for the requested turn
----Undo command is only sent when the player undoes a turn AND THEN MOVES, meaning you can discard all subsequent states from the database as soon as you recieve an undo command
---You do not need to send this info to the client, because the client can reconstruct previous states on its own. Thus it does not need any correspondence with our group

Also, do NOT save the entities (players, walls, flags, etc) in a 2d array. There are certain edge cases (like a log in frogger) where the entity takes up multiple tiles, the origin tile of the entity may be offscreen, or another entity may be on top of it.

Additionally you should be able to store multiple commands in a single turn and send them (for instance, all the cars in frogger would move at the same time, or a player might be allowed multiple moves in a turn). Also be able to send all the commands in an entire challenge mode match at the same time for playback mode.